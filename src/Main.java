

//Вы можете добавить консольный вывод для самопроверки в класcе Main, но на работу методов он влиять не должен.

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Check check = new Check();
        Scanner scanner = new Scanner(System.in);

        System.out.println("Поехали!");
        int scan;

        while (true) {
            check.printMenu();
            scan = scanner.nextInt();
            switch (scan) {
                case 1:

                    System.out.println("Добавили задачи");
                    break;
                case 2:

                    break;
                case 3:

                    System.out.println("Добавили 1 подзадачу");
                    break;
                default:
                    if (scan != 0) System.out.println("Команда не найдена. Повторите");
            }
            if (scan == 0) break;
        }
    }
}


    /*Хранение задач
Итак, вам нужно:
        1. Получать задачи по идентификатору
12,        Один из способов организовать такое хранение — это присвоить соответствие между идентификатором и
        задачей при помощи HashMap. Поскольку идентификатор не может повторяться (иначе он не был бы идентификатором),
        такой подход позволит быстро получать задачу.

        Чтобы получать разные типы задач, вы можете создать три HashMap по одной на каждый из видов задач.*/

    /*Обновление данных
    При обновлении можете считать, что на вход подаётся новый объект, который должен полностью заменить старый.
             К примеру, метод для обновления эпика может принимать эпик в качестве входных данных
public void updateTask(Task task). Если вы храните эпики в HashMap, где ключами являются идентификаторы,
        то обновление — это запись нового эпика tasks.put(task.getId(), task)).*/

    /*Обновление статуса задачи
        Фраза «информация приходит вместе с информацией по задаче» означает, что не существует отдельного метода,
        который занимался бы только обновлением статуса задачи. Вместо этого статус задачи обновляется вместе
        с полным обновлением задачи.

        Обновление эпиков
Из описания задачи видно, что эпик не управляет своим статусом самостоятельно. Это значит:
1. Пользователь не должен иметь возможности поменять статус эпика самостоятельно
2. Когда меняется статус любой подзадачи в эпике, вам необходимо проверить, что статус эпика изменится соответствующим
образом. При этом изменение статуса эпика может и не произойти, если в нём, к примеру, всё ещё есть незакрытые задачи.




Перед тем как приступить к задаче ответьте себе на вопросы:
Как распределяется функциональность приложения между классами?
Как классы должны взаимодействовать друг с другом ?
Как применить принципы ООП и построить систему наследования?
Какой способ выбрать для хранения задач?
Должен ли быть у приложения интерфейс?
Интересного вам программирования!


        */